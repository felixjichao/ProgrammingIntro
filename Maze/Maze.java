import java.util.LinkedList;


/**
 Maze class

 Stores information about a maze and can find a path through the maze
 (if there is one).

 Assumptions about structure of the maze, as given in mazeData, startLoc, and endLoc
 (parameters to constructor), and the path:
 -- no outer walls given in mazeData -- search assumes there is a virtual
 border around the maze (i.e., the maze path can't go outside of the maze
 boundaries)
 -- start location for a path is maze coordinate startLoc
 -- exit location is maze coordinate exitLoc
 -- mazeData input is a 2D array of booleans, where true means there is a wall
 at that location, and false means there isn't (see public FREE / WALL
 constants below)
 -- in mazeData the first index indicates the row. e.g., mazeData[row][col]
 -- only travel in 4 compass directions (no diagonal paths)
 -- can't travel through walls
 */

public class Maze {

    public static final boolean FREE = false;
    public static final boolean WALL = true;

    private static final int FREECOORD = 0;
    private static final int WALLCOORD = 1;
    private static final int VISITCOORD = 2;

    private int[][] mazeCoordData = null;
    private MazeCoord startLocation;
    private MazeCoord endLocation;
    private LinkedList<MazeCoord> validPath;

    /**
     Constructs a maze.
     @param mazeData the maze to search.  See general Maze comments for what
     goes in this array.
     @param startLoc the location in maze to start the search (not necessarily on an edge)
     @param endLoc the "exit" location of the maze (not necessarily on an edge)
     PRE: 0 <= startLoc.getRow() < mazeData.length and 0 <= startLoc.getCol() < mazeData[0].length
     and 0 <= endLoc.getRow() < mazeData.length and 0 <= endLoc.getCol() < mazeData[0].length

     */
    public Maze(boolean[][] mazeData, MazeCoord startLoc, MazeCoord endLoc) {
        // According to the mazeDate, initialize a 2D array of integers, where
        // 1 means there is a wall at that location, and 0 means there is not.
        mazeCoordData = new int[mazeData.length][mazeData[0].length];
        for (int i = 0; i < mazeData.length; i++) {
            for (int j = 0; j < mazeData[0].length; j++) {
                if (mazeData[i][j]) {
                    mazeCoordData[i][j] = WALLCOORD;
                } else {
                    mazeCoordData[i][j] = FREECOORD;
                }
            }
        }

        startLocation = startLoc;
        endLocation = endLoc;
        validPath = new LinkedList<MazeCoord>();
    }


    /**
     Returns the number of rows in the maze
     @return number of rows
     */
    public int numRows() {
        return mazeCoordData.length;
    }


    /**
     Returns the number of columns in the maze
     @return number of columns
     */
    public int numCols() {
        return mazeCoordData[0].length;
    }


    /**
     Returns true iff there is a wall at this location
     @param loc the location in maze coordinates
     @return whether there is a wall here
     PRE: 0 <= loc.getRow() < numRows() and 0 <= loc.getCol() < numCols()
     */
    public boolean hasWallAt(MazeCoord loc) {
        return mazeCoordData[loc.getRow()][loc.getCol()] == WALLCOORD;
    }


    /**
     Returns the entry location of this maze.
     */
    public MazeCoord getEntryLoc() {
        return startLocation;
    }


    /**
     Returns the exit location of this maze.
     */
    public MazeCoord getExitLoc() {
        return endLocation;
    }


    /**
     Returns the path through the maze. First element is starting location, and
     last element is exit location.  If there was not path, or if this is called
     before search, returns empty list.

     @return the maze path
     */
    public LinkedList<MazeCoord> getPath() {
        return validPath;
    }


    /**
     Find a path through the maze if there is one.  Client can access the
     path found via getPath method.
     @return whether path was found.
     */
    public boolean search()  {
        // Reset the positions that are marked as visited.
        for (int i = 0; i < this.numRows(); i++) {
            for (int j = 0; j < this.numCols(); j++) {
                if (mazeCoordData[i][j] == VISITCOORD) {
                    mazeCoordData[i][j] = FREECOORD;
                }
            }
        }

        // Clear all the elements in the list generated by last research
        validPath.clear();

        return this.searchHelper(startLocation);
    }

    /**
     The helper routine to do the actual recursion to search from a particular
     position to the end position.
     @param start start coordinates
     @return whether there is a path from start to the end position
     */
    private boolean searchHelper(MazeCoord start) {
        // start position having a wall means no path to the end
        if (this.hasWallAt(start)) {
            return false;
        }

        // start position marked as visited should not be visited again
        if (mazeCoordData[start.getRow()][start.getCol()] == VISITCOORD) {
            return false;
        }

        // Reach the end position
        if (start.equals(endLocation)) {
            validPath.addLast(endLocation);
            return true;
        }

        // Mark the start position as visited
        mazeCoordData[start.getRow()][start.getCol()] = VISITCOORD;
        int row = start.getRow();
        int col = start.getCol();

        // Search from the position above start if existing
        if (row - 1 >= 0 &&
                this.searchHelper(new MazeCoord(row - 1, col))) {
            validPath.addFirst(start);
            return true;
        }

        // Search from the position below start if existing
        if (row + 1 < this.numRows() &&
                this.searchHelper(new MazeCoord(row + 1, col))) {
            validPath.addFirst(start);
            return true;
        }

        // Search from the position on the left of start if existing
        if (col - 1 >= 0 &&
                this.searchHelper(new MazeCoord(row, col - 1))) {
            validPath.addFirst(start);
            return true;
        }

        // Search from the position on the right of start if existing
        if (col + 1 < this.numCols() &&
                this.searchHelper(new MazeCoord(row, col + 1))) {
            validPath.addFirst(start);
            return true;
        }

        return false;
    }
}